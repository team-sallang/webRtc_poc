import {
  createClient
} from "./chunk-PXWGKCGP.js";
import "./chunk-QH3POG6S.js";
import "./chunk-ROME4SDB.js";

// node_modules/trystero/src/utils.js
var { floor, random, sin } = Math;
var libName = "Trystero";
var alloc = (n, f) => Array(n).fill().map(f);
var charSet = "0123456789AaBbCcDdEeFfGgHhIiJjKkLlMmNnOoPpQqRrSsTtUuVvWwXxYyZz";
var genId = (n) => alloc(n, () => charSet[floor(random() * charSet.length)]).join("");
var selfId = genId(20);
var all = Promise.all.bind(Promise);
var isBrowser = typeof window !== "undefined";
var { entries, fromEntries, keys } = Object;
var noOp = () => {
};
var mkErr = (msg) => new Error(`${libName}: ${msg}`);
var encoder = new TextEncoder();
var decoder = new TextDecoder();
var encodeBytes = (txt) => encoder.encode(txt);
var decodeBytes = (buffer) => decoder.decode(buffer);
var topicPath = (...parts) => parts.join("@");
var toJson = JSON.stringify;
var fromJson = JSON.parse;
var reconnectionLockingPromise = null;
var resolver = null;
var pauseRelayReconnection = () => {
  if (!reconnectionLockingPromise) {
    reconnectionLockingPromise = new Promise((resolve) => {
      resolver = resolve;
    }).finally(() => {
      resolver = null;
      reconnectionLockingPromise = null;
    });
  }
};
var resumeRelayReconnection = () => (
  // resolver will be set to null after resolving.
  // Do not change here to avoid multiple calls to _resolver and creating new locker-promise
  // If not paused, do nothing
  resolver == null ? void 0 : resolver()
);
var watchOnline = () => {
  if (isBrowser) {
    const controller = new AbortController();
    addEventListener("online", resumeRelayReconnection, {
      signal: controller.signal
    });
    addEventListener("offline", pauseRelayReconnection, {
      signal: controller.signal
    });
    return () => controller.abort();
  }
  return noOp;
};

// node_modules/trystero/src/crypto.js
var algo = "AES-GCM";
var strToSha1 = {};
var pack = (buff) => btoa(String.fromCharCode.apply(null, new Uint8Array(buff)));
var unpack = (packed) => {
  const str = atob(packed);
  return new Uint8Array(str.length).map((_, i) => str.charCodeAt(i)).buffer;
};
var hashWith = async (algo2, str) => new Uint8Array(await crypto.subtle.digest(algo2, encodeBytes(str)));
var sha1 = async (str) => (
  // eslint-disable-next-line require-atomic-updates
  strToSha1[str] || (strToSha1[str] = Array.from(await hashWith("SHA-1", str)).map((b) => b.toString(36)).join(""))
);
var genKey = async (secret, appId, roomId) => crypto.subtle.importKey(
  "raw",
  await crypto.subtle.digest(
    { name: "SHA-256" },
    encodeBytes(`${secret}:${appId}:${roomId}`)
  ),
  { name: algo },
  false,
  ["encrypt", "decrypt"]
);
var joinChar = "$";
var ivJoinChar = ",";
var encrypt = async (keyP, plaintext) => {
  const iv = crypto.getRandomValues(new Uint8Array(16));
  return iv.join(ivJoinChar) + joinChar + pack(
    await crypto.subtle.encrypt(
      { name: algo, iv },
      await keyP,
      encodeBytes(plaintext)
    )
  );
};
var decrypt = async (keyP, raw) => {
  const [iv, c] = raw.split(joinChar);
  return decodeBytes(
    await crypto.subtle.decrypt(
      { name: algo, iv: new Uint8Array(iv.split(ivJoinChar)) },
      await keyP,
      unpack(c)
    )
  );
};

// node_modules/trystero/src/peer.js
var iceTimeout = 5e3;
var iceStateEvent = "icegatheringstatechange";
var offerType = "offer";
var answerType = "answer";
var peer_default = (initiator, { rtcConfig, rtcPolyfill, turnConfig }) => {
  const pc = new (rtcPolyfill || RTCPeerConnection)({
    iceServers: defaultIceServers.concat(turnConfig || []),
    ...rtcConfig
  });
  const handlers = {};
  let makingOffer = false;
  let isSettingRemoteAnswerPending = false;
  let dataChannel = null;
  const setupDataChannel = (channel) => {
    channel.binaryType = "arraybuffer";
    channel.bufferedAmountLowThreshold = 65535;
    channel.onmessage = (e) => {
      var _a;
      return (_a = handlers.data) == null ? void 0 : _a.call(handlers, e.data);
    };
    channel.onopen = () => {
      var _a;
      return (_a = handlers.connect) == null ? void 0 : _a.call(handlers);
    };
    channel.onclose = () => {
      var _a;
      return (_a = handlers.close) == null ? void 0 : _a.call(handlers);
    };
    channel.onerror = (err) => {
      var _a;
      return (_a = handlers.error) == null ? void 0 : _a.call(handlers, err);
    };
  };
  const waitForIceGathering = (pc2) => Promise.race([
    new Promise((res) => {
      const checkState = () => {
        if (pc2.iceGatheringState === "complete") {
          pc2.removeEventListener(iceStateEvent, checkState);
          res();
        }
      };
      pc2.addEventListener(iceStateEvent, checkState);
      checkState();
    }),
    new Promise((res) => setTimeout(res, iceTimeout))
  ]).then(() => ({
    type: pc2.localDescription.type,
    sdp: pc2.localDescription.sdp.replace(/a=ice-options:trickle\s\n/g, "")
  }));
  if (initiator) {
    dataChannel = pc.createDataChannel("data");
    setupDataChannel(dataChannel);
  } else {
    pc.ondatachannel = ({ channel }) => {
      dataChannel = channel;
      setupDataChannel(channel);
    };
  }
  pc.onnegotiationneeded = async () => {
    var _a, _b;
    try {
      makingOffer = true;
      await pc.setLocalDescription();
      const offer = await waitForIceGathering(pc);
      (_a = handlers.signal) == null ? void 0 : _a.call(handlers, offer);
    } catch (err) {
      (_b = handlers.error) == null ? void 0 : _b.call(handlers, err);
    } finally {
      makingOffer = false;
    }
  };
  pc.onconnectionstatechange = () => {
    var _a;
    if (["disconnected", "failed", "closed"].includes(pc.connectionState)) {
      (_a = handlers.close) == null ? void 0 : _a.call(handlers);
    }
  };
  pc.ontrack = (e) => {
    var _a, _b;
    (_a = handlers.track) == null ? void 0 : _a.call(handlers, e.track, e.streams[0]);
    (_b = handlers.stream) == null ? void 0 : _b.call(handlers, e.streams[0]);
  };
  pc.onremovestream = (e) => {
    var _a;
    return (_a = handlers.stream) == null ? void 0 : _a.call(handlers, e.stream);
  };
  if (initiator) {
    if (!pc.canTrickleIceCandidates) {
      pc.onnegotiationneeded();
    }
  }
  return {
    created: Date.now(),
    connection: pc,
    get channel() {
      return dataChannel;
    },
    get isDead() {
      return pc.connectionState === "closed";
    },
    async signal(sdp) {
      var _a, _b, _c;
      if ((dataChannel == null ? void 0 : dataChannel.readyState) === "open" && !((_a = sdp.sdp) == null ? void 0 : _a.includes("a=rtpmap"))) {
        return;
      }
      try {
        if (sdp.type === offerType) {
          if (makingOffer || pc.signalingState !== "stable" && !isSettingRemoteAnswerPending) {
            if (initiator) {
              return;
            }
            await all([
              pc.setLocalDescription({ type: "rollback" }),
              pc.setRemoteDescription(sdp)
            ]);
          } else {
            await pc.setRemoteDescription(sdp);
          }
          await pc.setLocalDescription();
          const answer = await waitForIceGathering(pc);
          (_b = handlers.signal) == null ? void 0 : _b.call(handlers, answer);
          return answer;
        } else if (sdp.type === answerType) {
          isSettingRemoteAnswerPending = true;
          try {
            await pc.setRemoteDescription(sdp);
          } finally {
            isSettingRemoteAnswerPending = false;
          }
        }
      } catch (err) {
        (_c = handlers.error) == null ? void 0 : _c.call(handlers, err);
      }
    },
    sendData: (data) => dataChannel.send(data),
    destroy: () => {
      dataChannel == null ? void 0 : dataChannel.close();
      pc.close();
      makingOffer = false;
      isSettingRemoteAnswerPending = false;
    },
    setHandlers: (newHandlers) => Object.assign(handlers, newHandlers),
    offerPromise: initiator ? new Promise(
      (res) => handlers.signal = (sdp) => {
        if (sdp.type === offerType) {
          res(sdp);
        }
      }
    ) : Promise.resolve(),
    addStream: (stream) => stream.getTracks().forEach((track) => pc.addTrack(track, stream)),
    removeStream: (stream) => pc.getSenders().filter((sender) => stream.getTracks().includes(sender.track)).forEach((sender) => pc.removeTrack(sender)),
    addTrack: (track, stream) => pc.addTrack(track, stream),
    removeTrack: (track) => {
      const sender = pc.getSenders().find((s) => s.track === track);
      if (sender) {
        pc.removeTrack(sender);
      }
    },
    replaceTrack: (oldTrack, newTrack) => {
      const sender = pc.getSenders().find((s) => s.track === oldTrack);
      if (sender) {
        return sender.replaceTrack(newTrack);
      }
    }
  };
};
var defaultIceServers = [
  ...alloc(3, (_, i) => `stun:stun${i || ""}.l.google.com:19302`),
  "stun:stun.cloudflare.com:3478"
].map((url) => ({ urls: url }));

// node_modules/trystero/src/room.js
var TypedArray = Object.getPrototypeOf(Uint8Array);
var typeByteLimit = 12;
var typeIndex = 0;
var nonceIndex = typeIndex + typeByteLimit;
var tagIndex = nonceIndex + 1;
var progressIndex = tagIndex + 1;
var payloadIndex = progressIndex + 1;
var chunkSize = 16 * 2 ** 10 - payloadIndex;
var oneByteMax = 255;
var buffLowEvent = "bufferedamountlow";
var internalNs = (ns) => "@_" + ns;
var room_default = (onPeer, onPeerLeave, onSelfLeave) => {
  const peerMap = {};
  const actions = {};
  const actionsCache = {};
  const pendingTransmissions = {};
  const pendingPongs = {};
  const pendingStreamMetas = {};
  const pendingTrackMetas = {};
  const listeners = {
    onPeerJoin: noOp,
    onPeerLeave: noOp,
    onPeerStream: noOp,
    onPeerTrack: noOp
  };
  const iterate = (targets, f) => (targets ? Array.isArray(targets) ? targets : [targets] : keys(peerMap)).flatMap((id) => {
    const peer = peerMap[id];
    if (!peer) {
      console.warn(`${libName}: no peer with id ${id} found`);
      return [];
    }
    return f(id, peer);
  });
  const exitPeer = (id) => {
    if (!peerMap[id]) {
      return;
    }
    peerMap[id].destroy();
    delete peerMap[id];
    delete pendingTransmissions[id];
    delete pendingPongs[id];
    listeners.onPeerLeave(id);
    onPeerLeave(id);
  };
  const makeAction = (type) => {
    if (actions[type]) {
      return actionsCache[type];
    }
    if (!type) {
      throw mkErr("action type argument is required");
    }
    const typeBytes = encodeBytes(type);
    if (typeBytes.byteLength > typeByteLimit) {
      throw mkErr(
        `action type string "${type}" (${typeBytes.byteLength}b) exceeds byte limit (${typeByteLimit}). Hint: choose a shorter name.`
      );
    }
    const typeBytesPadded = new Uint8Array(typeByteLimit);
    typeBytesPadded.set(typeBytes);
    let nonce = 0;
    actions[type] = {
      onComplete: noOp,
      onProgress: noOp,
      setOnComplete: (f) => actions[type] = { ...actions[type], onComplete: f },
      setOnProgress: (f) => actions[type] = { ...actions[type], onProgress: f },
      send: async (data, targets, meta, onProgress) => {
        if (meta && typeof meta !== "object") {
          throw mkErr("action meta argument must be an object");
        }
        const dataType = typeof data;
        if (dataType === "undefined") {
          throw mkErr("action data cannot be undefined");
        }
        const isJson = dataType !== "string";
        const isBlob = data instanceof Blob;
        const isBinary = isBlob || data instanceof ArrayBuffer || data instanceof TypedArray;
        if (meta && !isBinary) {
          throw mkErr("action meta argument can only be used with binary data");
        }
        const buffer = isBinary ? new Uint8Array(isBlob ? await data.arrayBuffer() : data) : encodeBytes(isJson ? toJson(data) : data);
        const metaEncoded = meta ? encodeBytes(toJson(meta)) : null;
        const chunkTotal = Math.ceil(buffer.byteLength / chunkSize) + (meta ? 1 : 0) || 1;
        const chunks = alloc(chunkTotal, (_, i) => {
          const isLast = i === chunkTotal - 1;
          const isMeta = meta && i === 0;
          const chunk = new Uint8Array(
            payloadIndex + (isMeta ? metaEncoded.byteLength : isLast ? buffer.byteLength - chunkSize * (chunkTotal - (meta ? 2 : 1)) : chunkSize)
          );
          chunk.set(typeBytesPadded);
          chunk.set([nonce], nonceIndex);
          chunk.set(
            [isLast | isMeta << 1 | isBinary << 2 | isJson << 3],
            tagIndex
          );
          chunk.set(
            [Math.round((i + 1) / chunkTotal * oneByteMax)],
            progressIndex
          );
          chunk.set(
            meta ? isMeta ? metaEncoded : buffer.subarray((i - 1) * chunkSize, i * chunkSize) : buffer.subarray(i * chunkSize, (i + 1) * chunkSize),
            payloadIndex
          );
          return chunk;
        });
        nonce = nonce + 1 & oneByteMax;
        return all(
          iterate(targets, async (id, peer) => {
            const { channel } = peer;
            let chunkN = 0;
            while (chunkN < chunkTotal) {
              const chunk = chunks[chunkN];
              if (channel.bufferedAmount > channel.bufferedAmountLowThreshold) {
                await new Promise((res) => {
                  const next = () => {
                    channel.removeEventListener(buffLowEvent, next);
                    res();
                  };
                  channel.addEventListener(buffLowEvent, next);
                });
              }
              if (!peerMap[id]) {
                break;
              }
              peer.sendData(chunk);
              chunkN++;
              onProgress == null ? void 0 : onProgress(chunk[progressIndex] / oneByteMax, id, meta);
            }
          })
        );
      }
    };
    return actionsCache[type] || (actionsCache[type] = [
      actions[type].send,
      actions[type].setOnComplete,
      actions[type].setOnProgress
    ]);
  };
  const handleData = (id, data) => {
    var _a, _b;
    const buffer = new Uint8Array(data);
    const type = decodeBytes(buffer.subarray(typeIndex, nonceIndex)).replaceAll(
      "\0",
      ""
    );
    const [nonce] = buffer.subarray(nonceIndex, tagIndex);
    const [tag] = buffer.subarray(tagIndex, progressIndex);
    const [progress] = buffer.subarray(progressIndex, payloadIndex);
    const payload = buffer.subarray(payloadIndex);
    const isLast = !!(tag & 1);
    const isMeta = !!(tag & 1 << 1);
    const isBinary = !!(tag & 1 << 2);
    const isJson = !!(tag & 1 << 3);
    if (!actions[type]) {
      console.warn(
        `${libName}: received message with unregistered type (${type})`
      );
      return;
    }
    pendingTransmissions[id] || (pendingTransmissions[id] = {});
    (_a = pendingTransmissions[id])[type] || (_a[type] = {});
    const target = (_b = pendingTransmissions[id][type])[nonce] || (_b[nonce] = { chunks: [] });
    if (isMeta) {
      target.meta = fromJson(decodeBytes(payload));
    } else {
      target.chunks.push(payload);
    }
    actions[type].onProgress(progress / oneByteMax, id, target.meta);
    if (!isLast) {
      return;
    }
    const full = new Uint8Array(
      target.chunks.reduce((a, c) => a + c.byteLength, 0)
    );
    target.chunks.reduce((a, c) => {
      full.set(c, a);
      return a + c.byteLength;
    }, 0);
    delete pendingTransmissions[id][type][nonce];
    if (isBinary) {
      actions[type].onComplete(full, id, target.meta);
    } else {
      const text = decodeBytes(full);
      actions[type].onComplete(isJson ? fromJson(text) : text, id);
    }
  };
  const leave = async () => {
    await sendLeave("");
    await new Promise((res) => setTimeout(res, 99));
    entries(peerMap).forEach(([id, peer]) => {
      peer.destroy();
      delete peerMap[id];
    });
    onSelfLeave();
  };
  const [sendPing, getPing] = makeAction(internalNs("ping"));
  const [sendPong, getPong] = makeAction(internalNs("pong"));
  const [sendSignal, getSignal] = makeAction(internalNs("signal"));
  const [sendStreamMeta, getStreamMeta] = makeAction(internalNs("stream"));
  const [sendTrackMeta, getTrackMeta] = makeAction(internalNs("track"));
  const [sendLeave, getLeave] = makeAction(internalNs("leave"));
  onPeer((peer, id) => {
    if (peerMap[id]) {
      return;
    }
    peerMap[id] = peer;
    peer.setHandlers({
      data: (d) => handleData(id, d),
      stream: (stream) => {
        listeners.onPeerStream(stream, id, pendingStreamMetas[id]);
        delete pendingStreamMetas[id];
      },
      track: (track, stream) => {
        listeners.onPeerTrack(track, stream, id, pendingTrackMetas[id]);
        delete pendingTrackMetas[id];
      },
      signal: (sdp) => sendSignal(sdp, id),
      close: () => exitPeer(id),
      error: (err) => {
        console.error(err);
        exitPeer(id);
      }
    });
    listeners.onPeerJoin(id);
  });
  getPing((_, id) => sendPong("", id));
  getPong((_, id) => {
    var _a;
    (_a = pendingPongs[id]) == null ? void 0 : _a.call(pendingPongs);
    delete pendingPongs[id];
  });
  getSignal((sdp, id) => {
    var _a;
    return (_a = peerMap[id]) == null ? void 0 : _a.signal(sdp);
  });
  getStreamMeta((meta, id) => pendingStreamMetas[id] = meta);
  getTrackMeta((meta, id) => pendingTrackMetas[id] = meta);
  getLeave((_, id) => exitPeer(id));
  if (isBrowser) {
    addEventListener("beforeunload", leave);
  }
  return {
    makeAction,
    leave,
    ping: async (id) => {
      if (!id) {
        throw mkErr("ping() must be called with target peer ID");
      }
      const start = Date.now();
      sendPing("", id);
      await new Promise((res) => pendingPongs[id] = res);
      return Date.now() - start;
    },
    getPeers: () => fromEntries(entries(peerMap).map(([id, peer]) => [id, peer.connection])),
    addStream: (stream, targets, meta) => iterate(targets, async (id, peer) => {
      if (meta) {
        await sendStreamMeta(meta, id);
      }
      peer.addStream(stream);
    }),
    removeStream: (stream, targets) => iterate(targets, (_, peer) => peer.removeStream(stream)),
    addTrack: (track, stream, targets, meta) => iterate(targets, async (id, peer) => {
      if (meta) {
        await sendTrackMeta(meta, id);
      }
      peer.addTrack(track, stream);
    }),
    removeTrack: (track, targets) => iterate(targets, (_, peer) => peer.removeTrack(track)),
    replaceTrack: (oldTrack, newTrack, targets, meta) => iterate(targets, async (id, peer) => {
      if (meta) {
        await sendTrackMeta(meta, id);
      }
      peer.replaceTrack(oldTrack, newTrack);
    }),
    onPeerJoin: (f) => listeners.onPeerJoin = f,
    onPeerLeave: (f) => listeners.onPeerLeave = f,
    onPeerStream: (f) => listeners.onPeerStream = f,
    onPeerTrack: (f) => listeners.onPeerTrack = f
  };
};

// node_modules/trystero/src/strategy.js
var poolSize = 20;
var announceIntervalMs = 5333;
var offerTtl = 57333;
var strategy_default = ({ init, subscribe, announce }) => {
  const occupiedRooms = {};
  let didInit = false;
  let initPromises;
  let offerPool;
  let offerCleanupTimer;
  let cleanupWatchOnline;
  return (config, roomId, onJoinError) => {
    var _a;
    const { appId } = config;
    if ((_a = occupiedRooms[appId]) == null ? void 0 : _a[roomId]) {
      return occupiedRooms[appId][roomId];
    }
    const pendingOffers = {};
    const connectedPeers = {};
    const rootTopicPlaintext = topicPath(libName, appId, roomId);
    const rootTopicP = sha1(rootTopicPlaintext);
    const selfTopicP = sha1(topicPath(rootTopicPlaintext, selfId));
    const key = genKey(config.password || "", appId, roomId);
    const withKey = (f) => async (signal) => ({
      type: signal.type,
      sdp: await f(key, signal.sdp)
    });
    const toPlain = withKey(decrypt);
    const toCipher = withKey(encrypt);
    const makeOffer = () => peer_default(true, config);
    const connectPeer = (peer, peerId, relayId) => {
      var _a2;
      if (connectedPeers[peerId]) {
        if (connectedPeers[peerId] !== peer) {
          peer.destroy();
        }
        return;
      }
      connectedPeers[peerId] = peer;
      onPeerConnect(peer, peerId);
      (_a2 = pendingOffers[peerId]) == null ? void 0 : _a2.forEach((peer2, i) => {
        if (i !== relayId) {
          peer2.destroy();
        }
      });
      delete pendingOffers[peerId];
    };
    const disconnectPeer = (peer, peerId) => {
      if (connectedPeers[peerId] === peer) {
        delete connectedPeers[peerId];
      }
    };
    const prunePendingOffer = (peerId, relayId) => {
      var _a2;
      if (connectedPeers[peerId]) {
        return;
      }
      const offer = (_a2 = pendingOffers[peerId]) == null ? void 0 : _a2[relayId];
      if (offer) {
        delete pendingOffers[peerId][relayId];
        offer.destroy();
      }
    };
    const getOffers = (n) => {
      offerPool.push(...alloc(n, makeOffer));
      return all(
        offerPool.splice(0, n).map(
          (peer) => peer.offerPromise.then(toCipher).then((offer) => ({ peer, offer }))
        )
      );
    };
    const handleJoinError = (peerId, sdpType) => onJoinError == null ? void 0 : onJoinError({
      error: `incorrect password (${config.password}) when decrypting ${sdpType}`,
      appId,
      peerId,
      roomId
    });
    const handleMessage = (relayId) => async (topic, msg, signalPeer) => {
      var _a2, _b, _c;
      const [rootTopic, selfTopic] = await all([rootTopicP, selfTopicP]);
      if (topic !== rootTopic && topic !== selfTopic) {
        return;
      }
      const { peerId, offer, answer, peer } = typeof msg === "string" ? fromJson(msg) : msg;
      if (peerId === selfId || connectedPeers[peerId]) {
        return;
      }
      if (peerId && !offer && !answer) {
        if ((_a2 = pendingOffers[peerId]) == null ? void 0 : _a2[relayId]) {
          return;
        }
        const [[{ peer: peer2, offer: offer2 }], topic2] = await all([
          getOffers(1),
          sha1(topicPath(rootTopicPlaintext, peerId))
        ]);
        pendingOffers[peerId] || (pendingOffers[peerId] = []);
        pendingOffers[peerId][relayId] = peer2;
        setTimeout(
          () => prunePendingOffer(peerId, relayId),
          announceIntervals[relayId] * 0.9
        );
        peer2.setHandlers({
          connect: () => connectPeer(peer2, peerId, relayId),
          close: () => disconnectPeer(peer2, peerId)
        });
        signalPeer(topic2, toJson({ peerId: selfId, offer: offer2 }));
      } else if (offer) {
        const myOffer = (_b = pendingOffers[peerId]) == null ? void 0 : _b[relayId];
        if (myOffer && selfId > peerId) {
          return;
        }
        const peer2 = peer_default(false, config);
        peer2.setHandlers({
          connect: () => connectPeer(peer2, peerId, relayId),
          close: () => disconnectPeer(peer2, peerId)
        });
        let plainOffer;
        try {
          plainOffer = await toPlain(offer);
        } catch {
          handleJoinError(peerId, "offer");
          return;
        }
        if (peer2.isDead) {
          return;
        }
        const [topic2, answer2] = await all([
          sha1(topicPath(rootTopicPlaintext, peerId)),
          peer2.signal(plainOffer)
        ]);
        signalPeer(
          topic2,
          toJson({ peerId: selfId, answer: await toCipher(answer2) })
        );
      } else if (answer) {
        let plainAnswer;
        try {
          plainAnswer = await toPlain(answer);
        } catch (e) {
          handleJoinError(peerId, "answer");
          return;
        }
        if (peer) {
          peer.setHandlers({
            connect: () => connectPeer(peer, peerId, relayId),
            close: () => disconnectPeer(peer, peerId)
          });
          peer.signal(plainAnswer);
        } else {
          const peer2 = (_c = pendingOffers[peerId]) == null ? void 0 : _c[relayId];
          if (peer2 && !peer2.isDead) {
            peer2.signal(plainAnswer);
          }
        }
      }
    };
    if (!config) {
      throw mkErr("requires a config map as the first argument");
    }
    if (!appId && !config.firebaseApp) {
      throw mkErr("config map is missing appId field");
    }
    if (!roomId) {
      throw mkErr("roomId argument required");
    }
    if (!didInit) {
      const initRes = init(config);
      offerPool = alloc(poolSize, makeOffer);
      initPromises = Array.isArray(initRes) ? initRes : [initRes];
      didInit = true;
      offerCleanupTimer = setInterval(
        () => offerPool = offerPool.filter((peer) => {
          const shouldLive = Date.now() - peer.created < offerTtl;
          if (!shouldLive) {
            peer.destroy();
          }
          return shouldLive;
        }),
        offerTtl * 1.03
      );
      cleanupWatchOnline = config.manualRelayReconnection ? noOp : watchOnline();
    }
    const announceIntervals = initPromises.map(() => announceIntervalMs);
    const announceTimeouts = [];
    const unsubFns = initPromises.map(
      async (relayP, i) => subscribe(
        await relayP,
        await rootTopicP,
        await selfTopicP,
        handleMessage(i),
        getOffers
      )
    );
    all([rootTopicP, selfTopicP]).then(([rootTopic, selfTopic]) => {
      const queueAnnounce = async (relay, i) => {
        const ms = await announce(relay, rootTopic, selfTopic);
        if (typeof ms === "number") {
          announceIntervals[i] = ms;
        }
        announceTimeouts[i] = setTimeout(
          () => queueAnnounce(relay, i),
          announceIntervals[i]
        );
      };
      unsubFns.forEach(async (didSub, i) => {
        await didSub;
        queueAnnounce(await initPromises[i], i);
      });
    });
    let onPeerConnect = noOp;
    occupiedRooms[appId] || (occupiedRooms[appId] = {});
    return occupiedRooms[appId][roomId] = room_default(
      (f) => onPeerConnect = f,
      (id) => delete connectedPeers[id],
      () => {
        delete occupiedRooms[appId][roomId];
        announceTimeouts.forEach(clearTimeout);
        unsubFns.forEach(async (f) => (await f)());
        clearInterval(offerCleanupTimer);
        cleanupWatchOnline();
        didInit = false;
      }
    );
  };
};

// node_modules/trystero/src/supabase.js
var events = {
  broadcast: "broadcast",
  join: "join",
  sdp: "sdp"
};
var joinRoom = strategy_default({
  init: (config) => createClient(config.appId, config.supabaseKey),
  subscribe: (client, rootTopic, selfTopic, onMessage) => {
    const allChans = [];
    const subscribe = (topic, cb) => {
      const chan = client.channel(topic);
      chan.subscribe(async (status) => {
        if (status === "SUBSCRIBED") {
          if (didUnsub) {
            client.removeChannel(chan);
            return;
          }
          allChans.push(chan);
          return cb(chan);
        }
        if (status === "CLOSED") {
          return;
        }
        await client.removeChannel(chan);
        setTimeout(() => subscribe(topic, cb), 999);
      });
    };
    const handleMessage = (peerTopic, signal) => subscribe(
      peerTopic,
      (chan) => chan.send({
        type: events.broadcast,
        event: events.sdp,
        payload: signal
      })
    );
    subscribe(
      selfTopic,
      (chan) => chan.on(
        events.broadcast,
        { event: events.sdp },
        ({ payload }) => onMessage(selfTopic, payload, handleMessage)
      )
    );
    subscribe(
      rootTopic,
      (chan) => chan.on(
        events.broadcast,
        { event: events.join },
        ({ payload }) => onMessage(rootTopic, payload, handleMessage)
      )
    );
    let didUnsub = false;
    return () => {
      allChans.forEach((chan) => client.removeChannel(chan));
      didUnsub = true;
    };
  },
  announce: (client, rootTopic) => client.channel(rootTopic).send({
    type: events.broadcast,
    event: events.join,
    payload: { peerId: selfId }
  })
});
export {
  joinRoom,
  selfId
};
//# sourceMappingURL=trystero_supabase.js.map
