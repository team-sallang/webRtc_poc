{
  "version": 3,
  "sources": ["../../trystero/src/utils.js", "../../trystero/src/crypto.js", "../../trystero/src/peer.js", "../../trystero/src/room.js", "../../trystero/src/strategy.js", "../../trystero/src/supabase.js"],
  "sourcesContent": ["const {floor, random, sin} = Math\n\nexport const libName = 'Trystero'\n\nexport const alloc = (n, f) => Array(n).fill().map(f)\n\nconst charSet = '0123456789AaBbCcDdEeFfGgHhIiJjKkLlMmNnOoPpQqRrSsTtUuVvWwXxYyZz'\n\nexport const genId = n =>\n  alloc(n, () => charSet[floor(random() * charSet.length)]).join('')\n\nexport const selfId = genId(20)\n\nexport const all = Promise.all.bind(Promise)\n\nexport const isBrowser = typeof window !== 'undefined'\n\nexport const {entries, fromEntries, keys} = Object\n\nexport const noOp = () => {}\n\nexport const mkErr = msg => new Error(`${libName}: ${msg}`)\n\nconst encoder = new TextEncoder()\nconst decoder = new TextDecoder()\n\nexport const encodeBytes = txt => encoder.encode(txt)\n\nexport const decodeBytes = buffer => decoder.decode(buffer)\n\nexport const toHex = buffer =>\n  buffer.reduce((a, c) => a + c.toString(16).padStart(2, '0'), '')\n\nexport const topicPath = (...parts) => parts.join('@')\n\nexport const shuffle = (xs, seed) => {\n  const a = [...xs]\n  const rand = () => {\n    const x = sin(seed++) * 10_000\n    return x - floor(x)\n  }\n\n  let i = a.length\n\n  while (i) {\n    const j = floor(rand() * i--)\n    ;[a[i], a[j]] = [a[j], a[i]]\n  }\n\n  return a\n}\n\nexport const getRelays = (config, defaults, defaultN, deriveFromAppId) => {\n  const relayUrls =\n    config.relayUrls ||\n    (deriveFromAppId ? shuffle(defaults, strToNum(config.appId)) : defaults)\n\n  return relayUrls.slice(\n    0,\n    config.relayUrls\n      ? config.relayUrls.length\n      : config.relayRedundancy || defaultN\n  )\n}\n\nexport const toJson = JSON.stringify\n\nexport const fromJson = JSON.parse\n\nexport const strToNum = (str, limit = Number.MAX_SAFE_INTEGER) =>\n  str.split('').reduce((a, c) => a + c.charCodeAt(0), 0) % limit\n\nconst defaultRetryMs = 3333\nconst socketRetryPeriods = {}\n\n// Prevents reconnection to the socket until the promise resolves\nlet reconnectionLockingPromise = null\n// Resolver for the promise that pauses reconnection\nlet resolver = null\n\n/**\n * Pauses reconnection attempts until resumed.\n * If already paused, no new promise is created.\n */\nexport const pauseRelayReconnection = () => {\n  if (!reconnectionLockingPromise) {\n    reconnectionLockingPromise = new Promise(resolve => {\n      resolver = resolve\n    }).finally(() => {\n      resolver = null\n      reconnectionLockingPromise = null\n    })\n  }\n}\n\n/**\n * Resumes reconnection attempts if they are currently paused.\n * If not paused, this function has no effect.\n */\nexport const resumeRelayReconnection = () =>\n  // resolver will be set to null after resolving.\n  // Do not change here to avoid multiple calls to _resolver and creating new locker-promise\n  // If not paused, do nothing\n  resolver?.()\n\nexport const makeSocket = (url, onMessage) => {\n  const client = {}\n\n  const init = () => {\n    const socket = new WebSocket(url)\n    socket.onclose = () => {\n      if (reconnectionLockingPromise) {\n        // If reconnect is paused, wait for the promise to resolve\n        reconnectionLockingPromise.then(init)\n        return\n      }\n      socketRetryPeriods[url] ??= defaultRetryMs\n      setTimeout(init, socketRetryPeriods[url])\n      socketRetryPeriods[url] *= 2\n    }\n\n    socket.onmessage = e => onMessage(e.data)\n    client.socket = socket\n    client.url = socket.url\n    client.ready = new Promise(\n      res =>\n        (socket.onopen = () => {\n          res(client)\n          socketRetryPeriods[url] = defaultRetryMs\n        })\n    )\n    client.send = data => {\n      if (socket.readyState === 1) {\n        socket.send(data)\n      }\n    }\n  }\n\n  init()\n\n  return client\n}\n\nexport const socketGetter = clientMap => () =>\n  fromEntries(entries(clientMap).map(([url, client]) => [url, client.socket]))\n\nexport const watchOnline = () => {\n  if (isBrowser) {\n    const controller = new AbortController()\n\n    addEventListener('online', resumeRelayReconnection, {\n      signal: controller.signal\n    })\n    addEventListener('offline', pauseRelayReconnection, {\n      signal: controller.signal\n    })\n\n    return () => controller.abort()\n  }\n\n  return noOp\n}\n", "import {decodeBytes, encodeBytes} from './utils.js'\n\nconst algo = 'AES-GCM'\nconst strToSha1 = {}\n\nconst pack = buff => btoa(String.fromCharCode.apply(null, new Uint8Array(buff)))\n\nconst unpack = packed => {\n  const str = atob(packed)\n  return new Uint8Array(str.length).map((_, i) => str.charCodeAt(i)).buffer\n}\n\nexport const hashWith = async (algo, str) =>\n  new Uint8Array(await crypto.subtle.digest(algo, encodeBytes(str)))\n\nexport const sha1 = async str =>\n  // eslint-disable-next-line require-atomic-updates\n  (strToSha1[str] ||= Array.from(await hashWith('SHA-1', str))\n    .map(b => b.toString(36))\n    .join(''))\n\nexport const genKey = async (secret, appId, roomId) =>\n  crypto.subtle.importKey(\n    'raw',\n    await crypto.subtle.digest(\n      {name: 'SHA-256'},\n      encodeBytes(`${secret}:${appId}:${roomId}`)\n    ),\n    {name: algo},\n    false,\n    ['encrypt', 'decrypt']\n  )\n\nconst joinChar = '$'\nconst ivJoinChar = ','\n\nexport const encrypt = async (keyP, plaintext) => {\n  const iv = crypto.getRandomValues(new Uint8Array(16))\n\n  return (\n    iv.join(ivJoinChar) +\n    joinChar +\n    pack(\n      await crypto.subtle.encrypt(\n        {name: algo, iv},\n        await keyP,\n        encodeBytes(plaintext)\n      )\n    )\n  )\n}\n\nexport const decrypt = async (keyP, raw) => {\n  const [iv, c] = raw.split(joinChar)\n\n  return decodeBytes(\n    await crypto.subtle.decrypt(\n      {name: algo, iv: new Uint8Array(iv.split(ivJoinChar))},\n      await keyP,\n      unpack(c)\n    )\n  )\n}\n", "import {all, alloc} from './utils.js'\n\nconst iceTimeout = 5000\nconst iceStateEvent = 'icegatheringstatechange'\nconst offerType = 'offer'\nconst answerType = 'answer'\n\nexport default (initiator, {rtcConfig, rtcPolyfill, turnConfig}) => {\n  const pc = new (rtcPolyfill || RTCPeerConnection)({\n    iceServers: defaultIceServers.concat(turnConfig || []),\n    ...rtcConfig\n  })\n\n  const handlers = {}\n  let makingOffer = false\n  let isSettingRemoteAnswerPending = false\n  let dataChannel = null\n\n  const setupDataChannel = channel => {\n    channel.binaryType = 'arraybuffer'\n    channel.bufferedAmountLowThreshold = 0xffff\n    channel.onmessage = e => handlers.data?.(e.data)\n    channel.onopen = () => handlers.connect?.()\n    channel.onclose = () => handlers.close?.()\n    channel.onerror = err => handlers.error?.(err)\n  }\n\n  const waitForIceGathering = pc =>\n    Promise.race([\n      new Promise(res => {\n        const checkState = () => {\n          if (pc.iceGatheringState === 'complete') {\n            pc.removeEventListener(iceStateEvent, checkState)\n            res()\n          }\n        }\n\n        pc.addEventListener(iceStateEvent, checkState)\n        checkState()\n      }),\n      new Promise(res => setTimeout(res, iceTimeout))\n    ]).then(() => ({\n      type: pc.localDescription.type,\n      sdp: pc.localDescription.sdp.replace(/a=ice-options:trickle\\s\\n/g, '')\n    }))\n\n  if (initiator) {\n    dataChannel = pc.createDataChannel('data')\n    setupDataChannel(dataChannel)\n  } else {\n    pc.ondatachannel = ({channel}) => {\n      dataChannel = channel\n      setupDataChannel(channel)\n    }\n  }\n\n  pc.onnegotiationneeded = async () => {\n    try {\n      makingOffer = true\n      await pc.setLocalDescription()\n      const offer = await waitForIceGathering(pc)\n\n      handlers.signal?.(offer)\n    } catch (err) {\n      handlers.error?.(err)\n    } finally {\n      makingOffer = false\n    }\n  }\n\n  pc.onconnectionstatechange = () => {\n    if (['disconnected', 'failed', 'closed'].includes(pc.connectionState)) {\n      handlers.close?.()\n    }\n  }\n\n  pc.ontrack = e => {\n    handlers.track?.(e.track, e.streams[0])\n    handlers.stream?.(e.streams[0])\n  }\n\n  pc.onremovestream = e => handlers.stream?.(e.stream)\n\n  if (initiator) {\n    if (!pc.canTrickleIceCandidates) {\n      pc.onnegotiationneeded()\n    }\n  }\n\n  return {\n    created: Date.now(),\n\n    connection: pc,\n\n    get channel() {\n      return dataChannel\n    },\n\n    get isDead() {\n      return pc.connectionState === 'closed'\n    },\n\n    async signal(sdp) {\n      if (\n        dataChannel?.readyState === 'open' &&\n        !sdp.sdp?.includes('a=rtpmap')\n      ) {\n        return\n      }\n\n      try {\n        if (sdp.type === offerType) {\n          if (\n            makingOffer ||\n            (pc.signalingState !== 'stable' && !isSettingRemoteAnswerPending)\n          ) {\n            if (initiator) {\n              return\n            }\n\n            await all([\n              pc.setLocalDescription({type: 'rollback'}),\n              pc.setRemoteDescription(sdp)\n            ])\n          } else {\n            await pc.setRemoteDescription(sdp)\n          }\n\n          await pc.setLocalDescription()\n          const answer = await waitForIceGathering(pc)\n          handlers.signal?.(answer)\n\n          return answer\n        } else if (sdp.type === answerType) {\n          isSettingRemoteAnswerPending = true\n          try {\n            await pc.setRemoteDescription(sdp)\n          } finally {\n            isSettingRemoteAnswerPending = false\n          }\n        }\n      } catch (err) {\n        handlers.error?.(err)\n      }\n    },\n\n    sendData: data => dataChannel.send(data),\n\n    destroy: () => {\n      dataChannel?.close()\n      pc.close()\n      makingOffer = false\n      isSettingRemoteAnswerPending = false\n    },\n\n    setHandlers: newHandlers => Object.assign(handlers, newHandlers),\n\n    offerPromise: initiator\n      ? new Promise(\n          res =>\n            (handlers.signal = sdp => {\n              if (sdp.type === offerType) {\n                res(sdp)\n              }\n            })\n        )\n      : Promise.resolve(),\n\n    addStream: stream =>\n      stream.getTracks().forEach(track => pc.addTrack(track, stream)),\n\n    removeStream: stream =>\n      pc\n        .getSenders()\n        .filter(sender => stream.getTracks().includes(sender.track))\n        .forEach(sender => pc.removeTrack(sender)),\n\n    addTrack: (track, stream) => pc.addTrack(track, stream),\n\n    removeTrack: track => {\n      const sender = pc.getSenders().find(s => s.track === track)\n      if (sender) {\n        pc.removeTrack(sender)\n      }\n    },\n\n    replaceTrack: (oldTrack, newTrack) => {\n      const sender = pc.getSenders().find(s => s.track === oldTrack)\n      if (sender) {\n        return sender.replaceTrack(newTrack)\n      }\n    }\n  }\n}\n\nexport const defaultIceServers = [\n  ...alloc(3, (_, i) => `stun:stun${i || ''}.l.google.com:19302`),\n  'stun:stun.cloudflare.com:3478'\n].map(url => ({urls: url}))\n", "import {\n  all,\n  alloc,\n  decodeBytes,\n  encodeBytes,\n  entries,\n  fromEntries,\n  fromJson,\n  isBrowser,\n  keys,\n  libName,\n  mkErr,\n  noOp,\n  toJson\n} from './utils.js'\n\nconst TypedArray = Object.getPrototypeOf(Uint8Array)\nconst typeByteLimit = 12\nconst typeIndex = 0\nconst nonceIndex = typeIndex + typeByteLimit\nconst tagIndex = nonceIndex + 1\nconst progressIndex = tagIndex + 1\nconst payloadIndex = progressIndex + 1\nconst chunkSize = 16 * 2 ** 10 - payloadIndex\nconst oneByteMax = 0xff\nconst buffLowEvent = 'bufferedamountlow'\nconst internalNs = ns => '@_' + ns\n\nexport default (onPeer, onPeerLeave, onSelfLeave) => {\n  const peerMap = {}\n  const actions = {}\n  const actionsCache = {}\n  const pendingTransmissions = {}\n  const pendingPongs = {}\n  const pendingStreamMetas = {}\n  const pendingTrackMetas = {}\n  const listeners = {\n    onPeerJoin: noOp,\n    onPeerLeave: noOp,\n    onPeerStream: noOp,\n    onPeerTrack: noOp\n  }\n\n  const iterate = (targets, f) =>\n    (targets\n      ? Array.isArray(targets)\n        ? targets\n        : [targets]\n      : keys(peerMap)\n    ).flatMap(id => {\n      const peer = peerMap[id]\n\n      if (!peer) {\n        console.warn(`${libName}: no peer with id ${id} found`)\n        return []\n      }\n\n      return f(id, peer)\n    })\n\n  const exitPeer = id => {\n    if (!peerMap[id]) {\n      return\n    }\n\n    peerMap[id].destroy()\n    delete peerMap[id]\n    delete pendingTransmissions[id]\n    delete pendingPongs[id]\n    listeners.onPeerLeave(id)\n    onPeerLeave(id)\n  }\n\n  const makeAction = type => {\n    if (actions[type]) {\n      return actionsCache[type]\n    }\n\n    if (!type) {\n      throw mkErr('action type argument is required')\n    }\n\n    const typeBytes = encodeBytes(type)\n\n    if (typeBytes.byteLength > typeByteLimit) {\n      throw mkErr(\n        `action type string \"${type}\" (${typeBytes.byteLength}b) exceeds ` +\n          `byte limit (${typeByteLimit}). Hint: choose a shorter name.`\n      )\n    }\n\n    const typeBytesPadded = new Uint8Array(typeByteLimit)\n    typeBytesPadded.set(typeBytes)\n\n    let nonce = 0\n\n    actions[type] = {\n      onComplete: noOp,\n      onProgress: noOp,\n\n      setOnComplete: f => (actions[type] = {...actions[type], onComplete: f}),\n\n      setOnProgress: f => (actions[type] = {...actions[type], onProgress: f}),\n\n      send: async (data, targets, meta, onProgress) => {\n        if (meta && typeof meta !== 'object') {\n          throw mkErr('action meta argument must be an object')\n        }\n\n        const dataType = typeof data\n\n        if (dataType === 'undefined') {\n          throw mkErr('action data cannot be undefined')\n        }\n\n        const isJson = dataType !== 'string'\n        const isBlob = data instanceof Blob\n        const isBinary =\n          isBlob || data instanceof ArrayBuffer || data instanceof TypedArray\n\n        if (meta && !isBinary) {\n          throw mkErr('action meta argument can only be used with binary data')\n        }\n\n        const buffer = isBinary\n          ? new Uint8Array(isBlob ? await data.arrayBuffer() : data)\n          : encodeBytes(isJson ? toJson(data) : data)\n\n        const metaEncoded = meta ? encodeBytes(toJson(meta)) : null\n\n        const chunkTotal =\n          Math.ceil(buffer.byteLength / chunkSize) + (meta ? 1 : 0) || 1\n\n        const chunks = alloc(chunkTotal, (_, i) => {\n          const isLast = i === chunkTotal - 1\n          const isMeta = meta && i === 0\n          const chunk = new Uint8Array(\n            payloadIndex +\n              (isMeta\n                ? metaEncoded.byteLength\n                : isLast\n                  ? buffer.byteLength -\n                    chunkSize * (chunkTotal - (meta ? 2 : 1))\n                  : chunkSize)\n          )\n\n          chunk.set(typeBytesPadded)\n          chunk.set([nonce], nonceIndex)\n          chunk.set(\n            [isLast | (isMeta << 1) | (isBinary << 2) | (isJson << 3)],\n            tagIndex\n          )\n          chunk.set(\n            [Math.round(((i + 1) / chunkTotal) * oneByteMax)],\n            progressIndex\n          )\n          chunk.set(\n            meta\n              ? isMeta\n                ? metaEncoded\n                : buffer.subarray((i - 1) * chunkSize, i * chunkSize)\n              : buffer.subarray(i * chunkSize, (i + 1) * chunkSize),\n            payloadIndex\n          )\n\n          return chunk\n        })\n\n        nonce = (nonce + 1) & oneByteMax\n\n        return all(\n          iterate(targets, async (id, peer) => {\n            const {channel} = peer\n            let chunkN = 0\n\n            while (chunkN < chunkTotal) {\n              const chunk = chunks[chunkN]\n\n              if (channel.bufferedAmount > channel.bufferedAmountLowThreshold) {\n                await new Promise(res => {\n                  const next = () => {\n                    channel.removeEventListener(buffLowEvent, next)\n                    res()\n                  }\n\n                  channel.addEventListener(buffLowEvent, next)\n                })\n              }\n\n              if (!peerMap[id]) {\n                break\n              }\n\n              peer.sendData(chunk)\n              chunkN++\n              onProgress?.(chunk[progressIndex] / oneByteMax, id, meta)\n            }\n          })\n        )\n      }\n    }\n\n    return (actionsCache[type] ||= [\n      actions[type].send,\n      actions[type].setOnComplete,\n      actions[type].setOnProgress\n    ])\n  }\n\n  const handleData = (id, data) => {\n    const buffer = new Uint8Array(data)\n    const type = decodeBytes(buffer.subarray(typeIndex, nonceIndex)).replaceAll(\n      '\\x00',\n      ''\n    )\n    const [nonce] = buffer.subarray(nonceIndex, tagIndex)\n    const [tag] = buffer.subarray(tagIndex, progressIndex)\n    const [progress] = buffer.subarray(progressIndex, payloadIndex)\n    const payload = buffer.subarray(payloadIndex)\n    const isLast = !!(tag & 1)\n    const isMeta = !!(tag & (1 << 1))\n    const isBinary = !!(tag & (1 << 2))\n    const isJson = !!(tag & (1 << 3))\n\n    if (!actions[type]) {\n      console.warn(\n        `${libName}: received message with unregistered type (${type})`\n      )\n      return\n    }\n\n    pendingTransmissions[id] ||= {}\n    pendingTransmissions[id][type] ||= {}\n\n    const target = (pendingTransmissions[id][type][nonce] ||= {chunks: []})\n\n    if (isMeta) {\n      target.meta = fromJson(decodeBytes(payload))\n    } else {\n      target.chunks.push(payload)\n    }\n\n    actions[type].onProgress(progress / oneByteMax, id, target.meta)\n\n    if (!isLast) {\n      return\n    }\n\n    const full = new Uint8Array(\n      target.chunks.reduce((a, c) => a + c.byteLength, 0)\n    )\n\n    target.chunks.reduce((a, c) => {\n      full.set(c, a)\n      return a + c.byteLength\n    }, 0)\n\n    delete pendingTransmissions[id][type][nonce]\n\n    if (isBinary) {\n      actions[type].onComplete(full, id, target.meta)\n    } else {\n      const text = decodeBytes(full)\n      actions[type].onComplete(isJson ? fromJson(text) : text, id)\n    }\n  }\n\n  const leave = async () => {\n    await sendLeave('')\n    await new Promise(res => setTimeout(res, 99))\n    entries(peerMap).forEach(([id, peer]) => {\n      peer.destroy()\n      delete peerMap[id]\n    })\n    onSelfLeave()\n  }\n\n  const [sendPing, getPing] = makeAction(internalNs('ping'))\n  const [sendPong, getPong] = makeAction(internalNs('pong'))\n  const [sendSignal, getSignal] = makeAction(internalNs('signal'))\n  const [sendStreamMeta, getStreamMeta] = makeAction(internalNs('stream'))\n  const [sendTrackMeta, getTrackMeta] = makeAction(internalNs('track'))\n  const [sendLeave, getLeave] = makeAction(internalNs('leave'))\n\n  onPeer((peer, id) => {\n    if (peerMap[id]) {\n      return\n    }\n\n    peerMap[id] = peer\n\n    peer.setHandlers({\n      data: d => handleData(id, d),\n      stream: stream => {\n        listeners.onPeerStream(stream, id, pendingStreamMetas[id])\n        delete pendingStreamMetas[id]\n      },\n      track: (track, stream) => {\n        listeners.onPeerTrack(track, stream, id, pendingTrackMetas[id])\n        delete pendingTrackMetas[id]\n      },\n      signal: sdp => sendSignal(sdp, id),\n      close: () => exitPeer(id),\n      error: err => {\n        console.error(err)\n        exitPeer(id)\n      }\n    })\n\n    listeners.onPeerJoin(id)\n  })\n\n  getPing((_, id) => sendPong('', id))\n\n  getPong((_, id) => {\n    pendingPongs[id]?.()\n    delete pendingPongs[id]\n  })\n\n  getSignal((sdp, id) => peerMap[id]?.signal(sdp))\n\n  getStreamMeta((meta, id) => (pendingStreamMetas[id] = meta))\n\n  getTrackMeta((meta, id) => (pendingTrackMetas[id] = meta))\n\n  getLeave((_, id) => exitPeer(id))\n\n  if (isBrowser) {\n    addEventListener('beforeunload', leave)\n  }\n\n  return {\n    makeAction,\n\n    leave,\n\n    ping: async id => {\n      if (!id) {\n        throw mkErr('ping() must be called with target peer ID')\n      }\n\n      const start = Date.now()\n\n      sendPing('', id)\n      await new Promise(res => (pendingPongs[id] = res))\n      return Date.now() - start\n    },\n\n    getPeers: () =>\n      fromEntries(entries(peerMap).map(([id, peer]) => [id, peer.connection])),\n\n    addStream: (stream, targets, meta) =>\n      iterate(targets, async (id, peer) => {\n        if (meta) {\n          await sendStreamMeta(meta, id)\n        }\n\n        peer.addStream(stream)\n      }),\n\n    removeStream: (stream, targets) =>\n      iterate(targets, (_, peer) => peer.removeStream(stream)),\n\n    addTrack: (track, stream, targets, meta) =>\n      iterate(targets, async (id, peer) => {\n        if (meta) {\n          await sendTrackMeta(meta, id)\n        }\n\n        peer.addTrack(track, stream)\n      }),\n\n    removeTrack: (track, targets) =>\n      iterate(targets, (_, peer) => peer.removeTrack(track)),\n\n    replaceTrack: (oldTrack, newTrack, targets, meta) =>\n      iterate(targets, async (id, peer) => {\n        if (meta) {\n          await sendTrackMeta(meta, id)\n        }\n\n        peer.replaceTrack(oldTrack, newTrack)\n      }),\n\n    onPeerJoin: f => (listeners.onPeerJoin = f),\n\n    onPeerLeave: f => (listeners.onPeerLeave = f),\n\n    onPeerStream: f => (listeners.onPeerStream = f),\n\n    onPeerTrack: f => (listeners.onPeerTrack = f)\n  }\n}\n", "import {decrypt, encrypt, genKey, sha1} from './crypto.js'\nimport initPeer from './peer.js'\nimport room from './room.js'\nimport {\n  all,\n  alloc,\n  fromJson,\n  libName,\n  mkErr,\n  noOp,\n  selfId,\n  toJson,\n  topicPath,\n  watchOnline\n} from './utils.js'\n\nconst poolSize = 20\nconst announceIntervalMs = 5_333\nconst offerTtl = 57_333\n\nexport default ({init, subscribe, announce}) => {\n  const occupiedRooms = {}\n\n  let didInit = false\n  let initPromises\n  let offerPool\n  let offerCleanupTimer\n  let cleanupWatchOnline\n\n  return (config, roomId, onJoinError) => {\n    const {appId} = config\n\n    if (occupiedRooms[appId]?.[roomId]) {\n      return occupiedRooms[appId][roomId]\n    }\n\n    const pendingOffers = {}\n    const connectedPeers = {}\n    const rootTopicPlaintext = topicPath(libName, appId, roomId)\n    const rootTopicP = sha1(rootTopicPlaintext)\n    const selfTopicP = sha1(topicPath(rootTopicPlaintext, selfId))\n    const key = genKey(config.password || '', appId, roomId)\n\n    const withKey = f => async signal => ({\n      type: signal.type,\n      sdp: await f(key, signal.sdp)\n    })\n\n    const toPlain = withKey(decrypt)\n    const toCipher = withKey(encrypt)\n\n    const makeOffer = () => initPeer(true, config)\n\n    const connectPeer = (peer, peerId, relayId) => {\n      if (connectedPeers[peerId]) {\n        if (connectedPeers[peerId] !== peer) {\n          peer.destroy()\n        }\n        return\n      }\n\n      connectedPeers[peerId] = peer\n      onPeerConnect(peer, peerId)\n\n      pendingOffers[peerId]?.forEach((peer, i) => {\n        if (i !== relayId) {\n          peer.destroy()\n        }\n      })\n      delete pendingOffers[peerId]\n    }\n\n    const disconnectPeer = (peer, peerId) => {\n      if (connectedPeers[peerId] === peer) {\n        delete connectedPeers[peerId]\n      }\n    }\n\n    const prunePendingOffer = (peerId, relayId) => {\n      if (connectedPeers[peerId]) {\n        return\n      }\n\n      const offer = pendingOffers[peerId]?.[relayId]\n\n      if (offer) {\n        delete pendingOffers[peerId][relayId]\n        offer.destroy()\n      }\n    }\n\n    const getOffers = n => {\n      offerPool.push(...alloc(n, makeOffer))\n\n      return all(\n        offerPool\n          .splice(0, n)\n          .map(peer =>\n            peer.offerPromise.then(toCipher).then(offer => ({peer, offer}))\n          )\n      )\n    }\n\n    const handleJoinError = (peerId, sdpType) =>\n      onJoinError?.({\n        error: `incorrect password (${config.password}) when decrypting ${sdpType}`,\n        appId,\n        peerId,\n        roomId\n      })\n\n    const handleMessage = relayId => async (topic, msg, signalPeer) => {\n      const [rootTopic, selfTopic] = await all([rootTopicP, selfTopicP])\n\n      if (topic !== rootTopic && topic !== selfTopic) {\n        return\n      }\n\n      const {peerId, offer, answer, peer} =\n        typeof msg === 'string' ? fromJson(msg) : msg\n\n      if (peerId === selfId || connectedPeers[peerId]) {\n        return\n      }\n\n      if (peerId && !offer && !answer) {\n        if (pendingOffers[peerId]?.[relayId]) {\n          return\n        }\n\n        const [[{peer, offer}], topic] = await all([\n          getOffers(1),\n          sha1(topicPath(rootTopicPlaintext, peerId))\n        ])\n\n        pendingOffers[peerId] ||= []\n        pendingOffers[peerId][relayId] = peer\n\n        setTimeout(\n          () => prunePendingOffer(peerId, relayId),\n          announceIntervals[relayId] * 0.9\n        )\n\n        peer.setHandlers({\n          connect: () => connectPeer(peer, peerId, relayId),\n          close: () => disconnectPeer(peer, peerId)\n        })\n\n        signalPeer(topic, toJson({peerId: selfId, offer}))\n      } else if (offer) {\n        const myOffer = pendingOffers[peerId]?.[relayId]\n\n        if (myOffer && selfId > peerId) {\n          return\n        }\n\n        const peer = initPeer(false, config)\n        peer.setHandlers({\n          connect: () => connectPeer(peer, peerId, relayId),\n          close: () => disconnectPeer(peer, peerId)\n        })\n\n        let plainOffer\n\n        try {\n          plainOffer = await toPlain(offer)\n        } catch {\n          handleJoinError(peerId, 'offer')\n          return\n        }\n\n        if (peer.isDead) {\n          return\n        }\n\n        const [topic, answer] = await all([\n          sha1(topicPath(rootTopicPlaintext, peerId)),\n          peer.signal(plainOffer)\n        ])\n\n        signalPeer(\n          topic,\n          toJson({peerId: selfId, answer: await toCipher(answer)})\n        )\n      } else if (answer) {\n        let plainAnswer\n\n        try {\n          plainAnswer = await toPlain(answer)\n        } catch (e) {\n          handleJoinError(peerId, 'answer')\n          return\n        }\n\n        if (peer) {\n          peer.setHandlers({\n            connect: () => connectPeer(peer, peerId, relayId),\n            close: () => disconnectPeer(peer, peerId)\n          })\n\n          peer.signal(plainAnswer)\n        } else {\n          const peer = pendingOffers[peerId]?.[relayId]\n\n          if (peer && !peer.isDead) {\n            peer.signal(plainAnswer)\n          }\n        }\n      }\n    }\n\n    if (!config) {\n      throw mkErr('requires a config map as the first argument')\n    }\n\n    if (!appId && !config.firebaseApp) {\n      throw mkErr('config map is missing appId field')\n    }\n\n    if (!roomId) {\n      throw mkErr('roomId argument required')\n    }\n\n    if (!didInit) {\n      const initRes = init(config)\n      offerPool = alloc(poolSize, makeOffer)\n      initPromises = Array.isArray(initRes) ? initRes : [initRes]\n      didInit = true\n      offerCleanupTimer = setInterval(\n        () =>\n          (offerPool = offerPool.filter(peer => {\n            const shouldLive = Date.now() - peer.created < offerTtl\n\n            if (!shouldLive) {\n              peer.destroy()\n            }\n\n            return shouldLive\n          })),\n        offerTtl * 1.03\n      )\n      cleanupWatchOnline = config.manualRelayReconnection ? noOp : watchOnline()\n    }\n\n    const announceIntervals = initPromises.map(() => announceIntervalMs)\n    const announceTimeouts = []\n\n    const unsubFns = initPromises.map(async (relayP, i) =>\n      subscribe(\n        await relayP,\n        await rootTopicP,\n        await selfTopicP,\n        handleMessage(i),\n        getOffers\n      )\n    )\n\n    all([rootTopicP, selfTopicP]).then(([rootTopic, selfTopic]) => {\n      const queueAnnounce = async (relay, i) => {\n        const ms = await announce(relay, rootTopic, selfTopic)\n\n        if (typeof ms === 'number') {\n          announceIntervals[i] = ms\n        }\n\n        announceTimeouts[i] = setTimeout(\n          () => queueAnnounce(relay, i),\n          announceIntervals[i]\n        )\n      }\n\n      unsubFns.forEach(async (didSub, i) => {\n        await didSub\n        queueAnnounce(await initPromises[i], i)\n      })\n    })\n\n    let onPeerConnect = noOp\n\n    occupiedRooms[appId] ||= {}\n\n    return (occupiedRooms[appId][roomId] = room(\n      f => (onPeerConnect = f),\n      id => delete connectedPeers[id],\n      () => {\n        delete occupiedRooms[appId][roomId]\n        announceTimeouts.forEach(clearTimeout)\n        unsubFns.forEach(async f => (await f)())\n        clearInterval(offerCleanupTimer)\n        cleanupWatchOnline()\n        didInit = false\n      }\n    ))\n  }\n}\n", "import {createClient} from '@supabase/supabase-js'\nimport strategy from './strategy.js'\nimport {selfId} from './utils.js'\n\nconst events = {\n  broadcast: 'broadcast',\n  join: 'join',\n  sdp: 'sdp'\n}\n\nexport const joinRoom = strategy({\n  init: config => createClient(config.appId, config.supabaseKey),\n\n  subscribe: (client, rootTopic, selfTopic, onMessage) => {\n    const allChans = []\n    const subscribe = (topic, cb) => {\n      const chan = client.channel(topic)\n\n      chan.subscribe(async status => {\n        if (status === 'SUBSCRIBED') {\n          if (didUnsub) {\n            client.removeChannel(chan)\n            return\n          }\n\n          allChans.push(chan)\n          return cb(chan)\n        }\n\n        if (status === 'CLOSED') {\n          return\n        }\n\n        await client.removeChannel(chan)\n        setTimeout(() => subscribe(topic, cb), 999)\n      })\n    }\n\n    const handleMessage = (peerTopic, signal) =>\n      subscribe(peerTopic, chan =>\n        chan.send({\n          type: events.broadcast,\n          event: events.sdp,\n          payload: signal\n        })\n      )\n\n    subscribe(selfTopic, chan =>\n      chan.on(events.broadcast, {event: events.sdp}, ({payload}) =>\n        onMessage(selfTopic, payload, handleMessage)\n      )\n    )\n\n    subscribe(rootTopic, chan =>\n      chan.on(events.broadcast, {event: events.join}, ({payload}) =>\n        onMessage(rootTopic, payload, handleMessage)\n      )\n    )\n\n    let didUnsub = false\n\n    return () => {\n      allChans.forEach(chan => client.removeChannel(chan))\n      didUnsub = true\n    }\n  },\n\n  announce: (client, rootTopic) =>\n    client.channel(rootTopic).send({\n      type: events.broadcast,\n      event: events.join,\n      payload: {peerId: selfId}\n    })\n})\n\nexport {selfId} from './utils.js'\n"],
  "mappings": "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",
  "names": ["algo", "pc", "_a", "peer", "offer", "topic", "answer"]
}
