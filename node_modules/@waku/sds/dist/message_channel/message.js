import { proto_sds_message } from "@waku/proto";
import { Logger } from "@waku/utils";
const log = new Logger("sds:message");
export class Message {
    messageId;
    channelId;
    senderId;
    causalHistory;
    lamportTimestamp;
    bloomFilter;
    content;
    retrievalHint;
    constructor(messageId, channelId, senderId, causalHistory, lamportTimestamp, bloomFilter, content, 
    /**
     * Not encoded, set after it is sent, used to include in follow-up messages
     */
    retrievalHint) {
        this.messageId = messageId;
        this.channelId = channelId;
        this.senderId = senderId;
        this.causalHistory = causalHistory;
        this.lamportTimestamp = lamportTimestamp;
        this.bloomFilter = bloomFilter;
        this.content = content;
        this.retrievalHint = retrievalHint;
    }
    encode() {
        return proto_sds_message.SdsMessage.encode(this);
    }
    static decode(data) {
        const { messageId, channelId, senderId, causalHistory, lamportTimestamp, bloomFilter, content } = proto_sds_message.SdsMessage.decode(data);
        if (testContentMessage({ lamportTimestamp, content })) {
            return new ContentMessage(messageId, channelId, senderId, causalHistory, lamportTimestamp, bloomFilter, content);
        }
        if (testEphemeralMessage({ lamportTimestamp, content })) {
            return new EphemeralMessage(messageId, channelId, senderId, causalHistory, undefined, bloomFilter, content);
        }
        if (testSyncMessage({ lamportTimestamp, content })) {
            return new SyncMessage(messageId, channelId, senderId, causalHistory, lamportTimestamp, bloomFilter, undefined);
        }
        log.error("message received was of unknown type", lamportTimestamp, content);
        return undefined;
    }
}
export class SyncMessage extends Message {
    messageId;
    channelId;
    senderId;
    causalHistory;
    lamportTimestamp;
    bloomFilter;
    content;
    retrievalHint;
    constructor(messageId, channelId, senderId, causalHistory, lamportTimestamp, bloomFilter, content, 
    /**
     * Not encoded, set after it is sent, used to include in follow-up messages
     */
    retrievalHint) {
        super(messageId, channelId, senderId, causalHistory, lamportTimestamp, bloomFilter, content, retrievalHint);
        this.messageId = messageId;
        this.channelId = channelId;
        this.senderId = senderId;
        this.causalHistory = causalHistory;
        this.lamportTimestamp = lamportTimestamp;
        this.bloomFilter = bloomFilter;
        this.content = content;
        this.retrievalHint = retrievalHint;
    }
}
function testSyncMessage(message) {
    return Boolean("lamportTimestamp" in message &&
        typeof message.lamportTimestamp === "number" &&
        (message.content === undefined || message.content.length === 0));
}
export function isSyncMessage(message) {
    return testSyncMessage(message);
}
export class EphemeralMessage extends Message {
    messageId;
    channelId;
    senderId;
    causalHistory;
    lamportTimestamp;
    bloomFilter;
    content;
    retrievalHint;
    constructor(messageId, channelId, senderId, causalHistory, lamportTimestamp, bloomFilter, content, 
    /**
     * Not encoded, set after it is sent, used to include in follow-up messages
     */
    retrievalHint) {
        if (!content || !content.length) {
            throw Error("Ephemeral Message must have content");
        }
        super(messageId, channelId, senderId, causalHistory, lamportTimestamp, bloomFilter, content, retrievalHint);
        this.messageId = messageId;
        this.channelId = channelId;
        this.senderId = senderId;
        this.causalHistory = causalHistory;
        this.lamportTimestamp = lamportTimestamp;
        this.bloomFilter = bloomFilter;
        this.content = content;
        this.retrievalHint = retrievalHint;
    }
}
export function isEphemeralMessage(message) {
    return testEphemeralMessage(message);
}
function testEphemeralMessage(message) {
    return Boolean(message.lamportTimestamp === undefined &&
        "content" in message &&
        message.content &&
        message.content.length);
}
export class ContentMessage extends Message {
    messageId;
    channelId;
    senderId;
    causalHistory;
    lamportTimestamp;
    bloomFilter;
    content;
    retrievalHint;
    constructor(messageId, channelId, senderId, causalHistory, lamportTimestamp, bloomFilter, content, 
    /**
     * Not encoded, set after it is sent, used to include in follow-up messages
     */
    retrievalHint) {
        if (!content.length) {
            throw Error("Content Message must have content");
        }
        super(messageId, channelId, senderId, causalHistory, lamportTimestamp, bloomFilter, content, retrievalHint);
        this.messageId = messageId;
        this.channelId = channelId;
        this.senderId = senderId;
        this.causalHistory = causalHistory;
        this.lamportTimestamp = lamportTimestamp;
        this.bloomFilter = bloomFilter;
        this.content = content;
        this.retrievalHint = retrievalHint;
    }
    // `valueOf` is used by comparison operands such as `<`
    valueOf() {
        // Create a sortable string representation that matches the compare logic
        // Pad lamportTimestamp to ensure proper lexicographic ordering
        // Use 16 digits to handle up to Number.MAX_SAFE_INTEGER (9007199254740991)
        const paddedTimestamp = this.lamportTimestamp.toString().padStart(16, "0");
        return `${paddedTimestamp}_${this.messageId}`;
    }
}
export function isContentMessage(message) {
    return testContentMessage(message);
}
function testContentMessage(message) {
    return Boolean("lamportTimestamp" in message &&
        typeof message.lamportTimestamp === "number" &&
        message.content &&
        message.content.length);
}
//# sourceMappingURL=message.js.map